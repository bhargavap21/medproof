pragma language_version 0.15;

import CompactStandardLibrary;

// Medical research proof structure
record MedicalProof {
  studyId: Field,
  hospitalCommitment: Field,
  proofHash: Field,
  timestamp: Field,
  verified: Bool
}

// Medical statistics (private inputs)
record MedicalStats {
  patientCount: Field,
  treatmentSuccess: Field,
  controlSuccess: Field,
  controlCount: Field,
  pValue: Field
}

// Public ledger state
export ledger totalStudies: Counter;
export ledger verifiedHospitals: Counter;
export ledger registeredProofs: Map<Field, MedicalProof>;

// Circuit to submit a medical research proof while keeping patient data private
export circuit submitMedicalProof(
  // Private inputs - never revealed on-chain
  secret patientData: MedicalStats,
  // Public inputs - visible on-chain
  public studyId: Field,
  public hospitalId: Field
): [] {
  
  // Validate minimum sample size (privacy-preserving constraint)
  assert(patientData.patientCount >= 50);
  
  // Validate statistical significance (p-value < 0.05, scaled by 1000)
  assert(patientData.pValue <= 50);
  
  // Calculate efficacy rate without revealing raw numbers
  let treatmentRate = patientData.treatmentSuccess * 1000 / patientData.patientCount;
  let controlRate = patientData.controlSuccess * 1000 / patientData.controlCount;
  
  // Ensure treatment is better than control
  assert(treatmentRate > controlRate);
  
  // Generate commitment to the medical data
  let dataCommitment = poseidon([
    patientData.patientCount,
    patientData.treatmentSuccess,
    patientData.controlSuccess,
    patientData.controlCount,
    patientData.pValue
  ]);
  
  // Create proof record with public metadata only
  let proof = MedicalProof {
    studyId: studyId,
    hospitalCommitment: poseidon([hospitalId, dataCommitment]),
    proofHash: poseidon([studyId, hospitalId, dataCommitment]),
    timestamp: now(),
    verified: true
  };
  
  // Store proof in public ledger
  registeredProofs.insert(studyId, proof);
  
  // Update counters
  totalStudies.increment(1);
}

// Circuit to verify a hospital's authorization (for multi-hospital studies)
export circuit authorizeHospital(
  public hospitalId: Field,
  public authorizationProof: Field
): [] {
  // Verify authorization signature/proof
  assert(authorizationProof != 0);
  
  // Update verified hospitals count
  verifiedHospitals.increment(1);
}

// Circuit for privacy-preserving aggregation across hospitals
export circuit aggregateResults(
  secret hospitalProofs: Vector<Field, 10>, // Up to 10 hospitals
  secret hospitalData: Vector<MedicalStats, 10>,
  public studyType: Field
): [Field, Field] {
  
  let totalPatients: Field = 0;
  let weightedEfficacy: Field = 0;
  let validHospitals: Field = 0;
  
  // Aggregate data across hospitals without revealing individual contributions
  for i in 0 to hospitalProofs.length {
    if hospitalProofs[i] != 0 {
      // Validate each hospital's data
      assert(hospitalData[i].patientCount >= 30);
      assert(hospitalData[i].pValue <= 50);
      
      // Add to aggregates
      totalPatients = totalPatients + hospitalData[i].patientCount;
      let hospitalEfficacy = hospitalData[i].treatmentSuccess * 1000 / hospitalData[i].patientCount;
      weightedEfficacy = weightedEfficacy + (hospitalEfficacy * hospitalData[i].patientCount);
      validHospitals = validHospitals + 1;
    }
  }
  
  // Calculate overall efficacy rate
  let overallEfficacy = weightedEfficacy / totalPatients;
  
  // Return aggregated statistics (without revealing individual hospital data)
  return [overallEfficacy, validHospitals];
}

// Query function to get study verification status (public data only)
export circuit getStudyStatus(public studyId: Field): [Bool, Field] {
  if registeredProofs.has(studyId) {
    let proof = registeredProofs.get(studyId);
    return [proof.verified, proof.timestamp];
  } else {
    return [false, 0];
  }
}